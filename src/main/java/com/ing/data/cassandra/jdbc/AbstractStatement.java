/*
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 */

package com.ing.data.cassandra.jdbc;

import org.apache.commons.lang3.StringUtils;

import java.io.InputStream;
import java.io.Reader;
import java.sql.Clob;
import java.sql.NClob;
import java.sql.PreparedStatement;
import java.sql.Ref;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.sql.SQLType;
import java.sql.SQLXML;
import java.sql.Wrapper;

import static com.ing.data.cassandra.jdbc.utils.DriverUtil.VALID_CQL_IDENTIFIER_PATTERN;
import static com.ing.data.cassandra.jdbc.utils.DriverUtil.VALID_QUOTED_CQL_IDENTIFIER_PATTERN;
import static com.ing.data.cassandra.jdbc.utils.ErrorConstants.INVALID_CQL_IDENTIFIER;
import static com.ing.data.cassandra.jdbc.utils.ErrorConstants.NOT_SUPPORTED;
import static com.ing.data.cassandra.jdbc.utils.ErrorConstants.NO_INTERFACE;
import static org.apache.commons.lang3.StringUtils.wrap;

/**
 * Provides a default implementation (returning a {@link SQLFeatureNotSupportedException}) to hold the unimplemented
 * methods of {@link java.sql.Statement} and {@link PreparedStatement} interfaces.
 */
@SuppressWarnings("unused")
abstract class AbstractStatement implements Wrapper {

    /*
     * From the Statement implementation.
     */

    public void cancel() throws SQLException {
        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
    }

    public boolean execute(final String cql, final int[] columnIndexes) throws SQLException {
        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
    }

    public boolean execute(final String cql, final String[] columnNames) throws SQLException {
        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
    }

    public int executeUpdate(final String cql, final int[] columnIndexes) throws SQLException {
        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
    }

    public int executeUpdate(final String cql, final String[] columnNames) throws SQLException {
        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
    }

    public ResultSet getGeneratedKeys() throws SQLException {
        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
    }

    public void setCursorName(final String name) throws SQLException {
        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
    }

    public long getLargeUpdateCount() throws SQLException {
        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
    }

    public void setLargeMaxRows(final long max) throws SQLException {
        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
    }

    public long[] executeLargeBatch() throws SQLException {
        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
    }

    public long executeLargeUpdate() throws SQLException {
        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
    }

    public long executeLargeUpdate(final String sql) throws SQLException {
        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
    }

    public long executeLargeUpdate(final String sql, final int autoGeneratedKeys) throws SQLException {
        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
    }

    public long executeLargeUpdate(final String sql, final int[] columnIndexes) throws SQLException {
        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
    }

    public long executeLargeUpdate(final String sql, final String[] columnNames) throws SQLException {
        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
    }

    /**
     * Returns a CQL identifier.
     * <p>
     *     If the identifier is a simple CQL identifier:
     *     <ul>
     *         <li>Return the original value if {@code alwaysQuote} is {@code false}</li>
     *         <li>Return a quoted identifier if {@code alwaysQuote} is {@code true}</li>
     *     </ul>
     *     If the identifier is not a simple CQL identifier, it will be enclosed in double quotes if not already
     *     present.
     * </p>
     * <p>
     *     A {@link SQLException} will be thrown if the identifier contains any characters invalid in a delimited
     *     identifier or if the identifier length is invalid for the datasource.
     * </p>
     *
     * @implSpec This implementation uses the following criteria to determine a valid simple CQL identifier:
     * <ul>
     *     <li>The string is not enclosed in double quotes</li>
     *     <li>The first character is an alphabetic character from a through z, or from A through Z</li>
     *     <li>The string only contains alphanumeric characters or the character "_"</li>
     * </ul>
     * <p>
     *     A {@link SQLException} will be thrown if the identifier contains a null character or double quote and is not
     *     a simple CQL identifier, and if the length of the identifier is less than 1 or greater than 48 characters.
     * </p>
     * @implNote In Cassandra, the maximal length for table and keyspace names is 48 characters. Even though the column
     * names can be longer, we use the shortest limit to implement this method. See
     * <a href="https://docs.datastax.com/en/cql-oss/3.3/cql/cql_reference/refLimits.html">CQL limits</a>, and
     * <a href="https://cassandra.apache.org/doc/latest/cassandra/developing/cql/definitions.html#identifiers">
     *     CQL identifiers definition</a>.
     *
     * @param identifier A CQL identifier.
     * @param alwaysQuote Indicates if a simple CQL identifier should be returned as a quoted identifier.
     * @return A simple CQL identifier or a quoted identifier.
     * @throws SQLException if the identifier is not a valid CQL identifier.
     * @throws NullPointerException if the identifier is {@code null}.
     */
    public String enquoteIdentifier(final String identifier, final boolean alwaysQuote) throws SQLException {
        if (isCqlIdentifierLengthValid(identifier)) {
            if (isSimpleIdentifier(identifier)) {
                if (alwaysQuote) {
                    return wrap(identifier, '"');
                }
                return identifier;
            } else {
                final String unquotedIdentifier = StringUtils.unwrap(identifier, '"');
                if (!identifier.contains("\u0000")
                    && VALID_QUOTED_CQL_IDENTIFIER_PATTERN.matcher(unquotedIdentifier).matches()) {
                    return StringUtils.wrapIfMissing(identifier, '"');
                } else {
                    throw new SQLException(INVALID_CQL_IDENTIFIER);
                }
            }
        } else {
            throw new SQLException(INVALID_CQL_IDENTIFIER);
        }
    }

    /**
     * Retrieves whether identifier is a simple CQL identifier.
     *
     * @implSpec This implementation uses the following criteria to determine a valid simple CQL identifier:
     * <ul>
     *     <li>The string is not enclosed in double quotes</li>
     *     <li>The first character is an alphabetic character from a through z, or from A through Z</li>
     *     <li>The string only contains alphanumeric characters or the character "_"</li>
     *     <li>The string is between 1 and 48 characters in length inclusive</li>
     * </ul>
     * @implNote In Cassandra, the maximal length for table and keyspace names is 48 characters. Even though the column
     * names can be longer, we use the shortest limit to implement this method. See
     * <a href="https://docs.datastax.com/en/cql-oss/3.3/cql/cql_reference/refLimits.html">CQL limits</a>, and
     * <a href="https://cassandra.apache.org/doc/latest/cassandra/developing/cql/definitions.html#identifiers">
     *     CQL identifiers definition</a>.
     * @param identifier A CQL identifier.
     * @return {@code true} if a simple SQL identifier, {@code false} otherwise.
     * @throws NullPointerException if the identifier is {@code null}.
     */
    public boolean isSimpleIdentifier(final String identifier) {
        return isCqlIdentifierLengthValid(identifier) && VALID_CQL_IDENTIFIER_PATTERN.matcher(identifier).matches();
    }

    private static boolean isCqlIdentifierLengthValid(final String identifier) {
        final int len = identifier.length();
        return len >= 1 && len <= 48;
    }

    /*
     * From the PreparedStatement implementation.
     */

    public void setAsciiStream(final int parameterIndex, final InputStream x) throws SQLException {
        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
    }

    public void setAsciiStream(final int parameterIndex,
                               final InputStream x,
                               final int length) throws SQLException {
        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
    }

    public void setAsciiStream(final int parameterIndex,
                               final InputStream x,
                               final long length) throws SQLException {
        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
    }

    public void setBinaryStream(final int parameterIndex, final InputStream x) throws SQLException {
        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
    }

    public void setBinaryStream(final int parameterIndex,
                                final InputStream x,
                                final int length) throws SQLException {
        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
    }

    public void setBinaryStream(final int parameterIndex,
                                final InputStream x,
                                final long length) throws SQLException {
        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
    }

    public void setBlob(final int parameterIndex,
                        final InputStream inputStream,
                        final long length) throws SQLException {
        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
    }

    public void setCharacterStream(final int parameterIndex, final Reader reader) throws SQLException {
        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
    }

    public void setCharacterStream(final int parameterIndex,
                                   final Reader reader,
                                   final long length) throws SQLException {
        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
    }

    public void setClob(final int parameterIndex, final Clob x) throws SQLException {
        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
    }

    public void setClob(final int parameterIndex, final Reader reader) throws SQLException {
        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
    }

    public void setClob(final int parameterIndex,
                        final Reader reader,
                        final long length) throws SQLException {
        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
    }

    public void setNCharacterStream(final int parameterIndex, final Reader value) throws SQLException {
        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
    }

    public void setNCharacterStream(final int parameterIndex,
                                    final Reader value,
                                    final long length) throws SQLException {
        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
    }

    public void setNClob(final int parameterIndex, final NClob value) throws SQLException {
        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
    }

    public void setNClob(final int parameterIndex, final Reader reader) throws SQLException {
        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
    }

    public void setNClob(final int parameterIndex,
                         final Reader reader,
                         final long length) throws SQLException {
        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
    }

    public void setRef(final int parameterIndex, final Ref x) throws SQLException {
        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
    }

    public void setSQLXML(final int parameterIndex, final SQLXML xmlObject) throws SQLException {
        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
    }

    /**
     * Sets the designated parameter to the given input stream, which will have the specified number of bytes.
     * <p>
     *     <b>Note:</b> This stream object can either be a standard Java stream object or your own subclass that
     *     implements the standard interface.
     * </p>
     *
     * @param parameterIndex The first parameter is 1, the second is 2, ...
     * @param x An {@link InputStream} object that contains the Unicode parameter value.
     * @param length The number of bytes in the stream.
     * @throws SQLException if {@code parameterIndex} does not correspond to a parameter marker in the SQL statement;
     * if a database access error occurs or this method is called on a closed {@link PreparedStatement}.
     * @throws SQLFeatureNotSupportedException since the JDBC driver does not support this method.
     * @deprecated Use {@link PreparedStatement#setCharacterStream(int, Reader, int)} instead.
     */
    @Deprecated(since = "1.2")
    public void setUnicodeStream(final int parameterIndex,
                                 final InputStream x,
                                 final int length) throws SQLException {
        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
    }

    public void setObject(final int parameterIndex,
                          final Object x,
                          final SQLType targetSqlType,
                          final int scaleOrLength) throws SQLException {
        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
    }

    public void setObject(final int parameterIndex,
                          final Object x,
                          final SQLType targetSqlType) throws SQLException {
        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
    }

    @Override
    public boolean isWrapperFor(final Class<?> iface) throws SQLException {
        return iface != null && iface.isAssignableFrom(this.getClass());
    }

    @Override
    public <T> T unwrap(final Class<T> iface) throws SQLException {
        if (isWrapperFor(iface)) {
            return iface.cast(this);
        } else {
            throw new SQLException(String.format(NO_INTERFACE, iface.getSimpleName()));
        }
    }
}
